[test_generation_prompt]
system="""\
"""

user="""\
# Overview
- You are an expert software engineer tasked with writing some end-to-end tests.
- You will be given a Protobuf file containing gRPC service definitions. Your task is to generate
end-to-end tests in a custom format that utilizes an internal testing framework.
- Each end-to-end test consists of calling a gRPC service and confirming that the request was successful.

Additional guidelines:
- Carefully analyze the provided Protobuf file. Understand the various messages that are defined in the Protobuf and how they are used.
- Fields that are required to be in the request message have docstrings that contain the phrase "[REQUIRED]".
When writing the end-to-end test, be sure to include those fields.
- Ensure that all new code added is valid Kotlin code, has no syntactic errors and can actually compile.

## Examples
The following section provides an example of the test suite you are expected to generate.

=========
class GreetingServiceLoadgenModule : AbstractModule() {

    // Max. QPS that the test can reach
    private val maxQPS = 500

    // This is the total no. of runs to execute
    private val totalRuns = 500

    // How frequently this test is run
    private val jobFrequency = Duration.ofMinutes(15).toKotlinDuration()

    // Allows us to run the job at the same cadence but not at exactly the same time
    private val maxJitter = Duration.ofSeconds(60).toKotlinDuration()

    @ProvidesIntoSet
    @Inject
    fun getGreetingLoadgenJob(client: GreetingServiceCoroutineStub): LoadgenJob {
        return LoadgenJob.ofRecurring(
            name = "get-greeting-test",
            totalRuns = totalRuns,
            qpsRateLimit = maxQPS,
            frequency = jobFrequency,
            maxJitter = maxJitter,
        ) {
            val name = "dev platypus"
            val resp = client.getGreeting(
                GetGreetingRequest.newBuilder().setUserName(name).build(),
            )
        }
    }
}
=========

Things to consider about this output:

- The name of the class is derived from the name of the service defined in the Protobuf file. E.g. if the name
of the service is `GreetingService` then the class would be called `GreetingServiceLoadgenModule`.
- Each rpc method defined in the Protobuf file has a corresponding method in the Kotlin class.
The name of the method is derived from the name of the rpc defined in the Protobuf file. E.g. an rpc method
called `GetGreeting` will have a method called `getGreetingLoadgenJob`.
- The test method takes in a `client` parameter. This is a Kotlin client stub that is generated from the Protobuf
definition. Name of the client stub class is also dependent on the name of the gRPC service. E.g. if the service
is called `GreetingService` in Protobuf, then the client's type will be `GreetingServiceCoroutineStub`.

=========

## Actual Data

The following section provides the actual input that you will be working with. You need to process it
based on the guidelines provided above.

### Service definition in Protobuf
Here is the actual Protobuf definition that you will be working with.

=========
{{ protobuf_definition|trim }}
=========


## Additional Protobuf files
It is possible that the request and response messages used to call the RPC methods are distributed across multiple
files. In that case, the contents of those additional files are provided below. Use them to identify the
nature and contents of the Protobuf messages.

{%- if additional_includes_section|trim %}
=========

{{ additional_includes_section|trim }}

=========
{% endif %}


{%- if additional_instructions_text|trim  %}

{{ additional_instructions_text|trim }}
{% endif %}

## Instructions:
- If you received multiple Protobuf files, combine the contents of all the Protobuf files
  into a single Protobuf file.
- Identify the list of rpc methods defined in the combined Protobuf file.
- Generate the test suite for the service defined in the Protobuf file as shown above.
- For each rpc method defined in the Protobuf file, generate a test as shown above.
- Add the appropriate package name and imports to the generated Kotlin class.

## Expected Response

Your response should **ONLY** contain the Kotlin class the represents the generated test suite.
**DO NOT** include any formatting, additional context or explanation on how or why this test suite was generated.
"""
